using Application.Factory.Interfaces;
using Application.Parser.Interface;
using Application.Services.Interfaces;
using Core.Models.Scan;
using Core.Models.Vulnerabilities;
using Infrastructure.Provider.Interface;
using Microsoft.Extensions.Logging;

namespace Application.Services;

public class VulnerabilityScannerService : IVulnerabilityScannerService
{
    private readonly IVulnerabilityProvider _vulnerabilityProvider;
    private readonly IPackageFileParserFactory _packageFileParserFactory;
    private readonly ILogger<VulnerabilityScannerService> _logger;

    public VulnerabilityScannerService(IVulnerabilityProvider vulnerabilityProvider, IPackageFileParserFactory packageFileParserFactory, ILogger<VulnerabilityScannerService> logger)
    {
        _vulnerabilityProvider = vulnerabilityProvider;
        _packageFileParserFactory = packageFileParserFactory;
        _logger = logger;
    }

    public async Task<ScanResponseEntity> ScanAsync(ScanRequestEntity request)
    {
        try
        {
            if (string.IsNullOrWhiteSpace(request.Ecosystem))
            {
                throw new ArgumentException("Ecosystem is required");
            }

            if (string.IsNullOrWhiteSpace(request.FileContent))
            {
                throw new ArgumentException("FileContent is required");
            }

            IPackageFileParser scanner = _packageFileParserFactory.GetParser(request.Ecosystem);

            IReadOnlyDictionary<string, string> dependencies = scanner.ParseDependencies(request.FileContent);

            if (!dependencies.Any())
            {
                _logger.LogWarning("No dependencies found in the provided file content for ecosystem {Ecosystem}", request.Ecosystem);
                return new ScanResponseEntity();
            }

            IReadOnlyCollection<VulnerablePackage> vulnerablePackages = await _vulnerabilityProvider.GetVulnerabilitiesAsync(request.Ecosystem, dependencies);

            return new ScanResponseEntity { VulnerablePackages = vulnerablePackages };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to execute {} for {} [{}]", nameof(ScanAsync), nameof(request), request);
            throw;
        }
    }
}